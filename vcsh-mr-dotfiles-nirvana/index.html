<section id="table-of-contents" class="toc">
  <header>
    <h3>Overview</h3>
  </header>
<div id="drawer">
<ul id="markdown-toc">
  <li><a href="#dotfiles" id="markdown-toc-dotfiles">Dotfiles</a></li>
  <li><a href="#bootstrapping" id="markdown-toc-bootstrapping">Bootstrapping</a></li>
  <li><a href="#organization" id="markdown-toc-organization">Organization</a></li>
  <li><a href="#walk-through" id="markdown-toc-walk-through">Walk-through</a>    <ul>
      <li><a href="#adding-a-new-repository" id="markdown-toc-adding-a-new-repository">Adding a new repository</a></li>
      <li><a href="#reproduction-of-configuration" id="markdown-toc-reproduction-of-configuration">Reproduction of configuration</a></li>
      <li><a href="#updating-a-repository" id="markdown-toc-updating-a-repository">Updating a repository</a></li>
      <li><a href="#gitignore" id="markdown-toc-gitignore">gitignore</a></li>
    </ul>
  </li>
  <li><a href="#caveats" id="markdown-toc-caveats">Caveats</a></li>
</ul>

  </div>
</section>
<!-- /#table-of-contents -->

<h2 id="dotfiles">Dotfiles</h2>

<p>When I started on the path of managing my dotfiles, I was naive enough to believe that my scripting abilities would let me conquer the beast that <em>dotfiles</em> are, and it took me a couple of years to realize my folly. But I’ve decided to mend my ways, to follow the wisdom of the ages - <strong>UNIX way</strong>.</p>

<h2 id="bootstrapping">Bootstrapping</h2>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo apt-get install -y vcsh myrepos
git clone git@github.com:srijanshetty/vcsh-mr.git
mr up</code></pre></div>

<p>Want to get down and dirty? You need to go <a href="#walk-through">here</a></p>

<h2 id="organization">Organization</h2>

<p>There are three vital pieces of the puzzle: vcsh, mr and the directory structure of mr.</p>

<ol>
  <li>
    <p><strong>vcsh</strong>: The ~500 LOC of vcsh bellies it unfathomable power. Like every great UNIX utility, vcsh builds upon another great UNIX utility - <em>git</em>. Git allows for the $GIT_DIR to be separate from the $GIT_WORKING_TREE. What this means is that the ‘.git
‘ directory could be located in another folder and Git would still work fine. vcsh keeps all these ‘.git’ folders in ~/.config/vcsh/repo.d/REPO_NAME.git. And the work trees are maintained in $HOME. So, we can have multiple git directories residing within home and none of them will collide with each other. Awesome isn’t it?</p>
  </li>
  <li>
    <p><strong>mr</strong>: mr allows to manage multiple repositories together. You register repositories with mr (Using <em>mr reg</em>, D’oh) and then you can execute VCS commands like push, update, checkout on them together. mr supports all popular version controls systems. (I only care about git though).</p>
  </li>
  <li>
    <p><strong>Directory Structure</strong>: The author of the vcsh work flow prescribes the following directory structure:</p>
  </li>
</ol>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">~/.config/mr/
    ├── available.d
    │   ├── beets.vcsh
    │   ├── git.vcsh
    │   ├── ledger.vcsh
    │   ├── misc.vcsh
    │   ├── mr.vcsh
    │   ├── template.vcsh
    │   ├── tmux.vcsh
    │   ├── vim.vcsh
    │   ├── xmonad.vcsh
    │   └── zsh.vcsh
    └── config.d
        ├── beets.vcsh -&gt; ../available.d/beets.vcsh
        ├── git.vcsh -&gt; ../available.d/git.vcsh
        ├── ledger.vcsh -&gt; ../available.d/ledger.vcsh
        ├── misc.vcsh -&gt; ../available.d/misc.vcsh
        ├── mr.vcsh -&gt; ../available.d/mr.vcsh
        ├── tmux.vcsh -&gt; ../available.d/tmux.vcsh
        ├── vim.vcsh -&gt; ../available.d/vim.vcsh
        └── zsh.vcsh -&gt; ../available.d/zsh.vcsh</code></pre></div>

<p>Some salient points about this directory structure are:
- <strong>available.d</strong> serves as a store for different available configurations.
- active configurations are symlinked in <strong>config.d</strong>.
- mr acts only on the configurations listed in <strong>config.d</strong>.</p>

<p>What’s wonderful about these three tools is that they were written by the same author and work together seamlessly!!</p>

<p><strong>Note</strong>: Maintaining symlinks seemed too much of a chore for me; and so I did what any respectable programmer would do - <a href="https://github.com/srijanshetty/custom/blob/master/functions/myrepos.zsh">automate it</a></p>

<h2 id="walk-through">Walk-through</h2>

<p>It took me three tries - with the last one taking over a day - in a span of over 4 months to get this straight. <a href="http://www.martin-burger.net/blog/unix-shell/manage-dotfiles-quickly-and-effortlessly/">This</a>) guide did wonders.</p>

<p>Caveat: A lot of this section is derivative of the about mentioned article.</p>

<h3 id="adding-a-new-repository">Adding a new repository</h3>

<p>If you want to manage a new tool and its dotfiles with vcsh and myrepos, follow the steps given below using ack as example.</p>

<ul>
  <li>Create a new remote repository for the tool you want to manage with vcsh.</li>
</ul>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">vcsh init ack</code></pre></div>

<ul>
  <li>The URL to clone that repository might look like: <em>git@github.com/vcsh-ack.git</em>.</li>
  <li>Add new myrepos config file <em>~/.config/mr/available.d/ack.vcsh</em>, which might look as follows:</li>
</ul>

<div class="highlight"><pre><code class="language-ini" data-lang="ini"><span class="k">[$HOME/.config/vcsh/repo.d/ack.git]</span>
<span class="na">checkout</span> <span class="o">=</span> <span class="s">vcsh clone git@github.com:srijanshetty/vcsh-ack.git ack</span></code></pre></div>

<ul>
  <li>Create a symbolic link to tell mr to include this repository:</li>
</ul>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd</span> ~/.config/mr/config.d/
ln -s ../available.d/ack.vcsh .</code></pre></div>

<ul>
  <li>Commit and push your changes in your local myrepos repository:</li>
</ul>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">vcsh mr add ~/.config/mr
vcsh mr commit -m <span class="s2">&quot;[ack] add vcsh repository&quot;</span>
vcsh mr push</code></pre></div>

<ul>
  <li>Add the tool’s dotfiles by to vcsh.</li>
</ul>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">vcsh ack add .ackrc</code></pre></div>

<ul>
  <li>Create, customize, and add the tool-specific excludesfile. (More info about it over <a href="#gitignore">here</a>)</li>
</ul>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">vcsh write-gitignore ack
vcsh ack add -f .gitignore.d/ack
vcsh write-gitignore ack
vcsh ack add .gitignore.d/ack</code></pre></div>

<ul>
  <li>Commit and push your changes in your local ack repository:</li>
</ul>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">vcsh ack commit -m <span class="s2">&quot;[Initial Commit] add initial ackrc file&quot;</span>
vcsh ack push</code></pre></div>

<p>Yes, the initial configuration is quite complicated. But the effort is well worth what comes next.</p>

<h3 id="reproduction-of-configuration">Reproduction of configuration</h3>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo apt-get install -y vcsh myrepos
vcsh clone git@github.com:srijanshetty/vcsh-mr.git
mr up</code></pre></div>

<p>Bam! It’s done!</p>

<h3 id="updating-a-repository">Updating a repository</h3>

<p>The work-flow for adding new files/updating files is simple enough.</p>

<ul>
  <li>After updating the files or adding new files, run:</li>
</ul>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">vcsh &lt;REPO_NAME&gt; add &lt;FILE_NAME&gt;</code></pre></div>

<ul>
  <li>Then commit the changes and push</li>
</ul>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">vcsh &lt;REPO_NAME&gt; commit -m <span class="s2">&quot;Yowza!&quot;</span>
vcsh &lt;REPO_NAME&gt; push</code></pre></div>

<p>As can be seen, vcsh supports all common VCS commands. An easier work-flow is to enter a <em>vcsh chroot</em>, demonstrated as follows:</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">vcsh enter REPO_NAME
ga &lt;FILE_NAME&gt;
gcm <span class="s2">&quot;Yowza!&quot;</span>
git push
<span class="nb">exit</span></code></pre></div>

<p>Not only does this enable the git prompt, but also you can use those aliases that you set. Could this get any better?</p>

<h3 id="gitignore">gitignore</h3>

<p>If you tried entering the <em>vcsh chroot</em> that I just talked about and you use a git prompt (you do use it don’t you), then you’re in for a treat - your terminal may have frozen for a good amount of time; and if you’re like me you would have given up on this vcsh business already. But fret not, such behaviour is expected. Git prompts make use of ls-files and with over 25,000 files in my $HOME, this king of tardiness is expected.</p>

<p>To get around this problem, we need to define a <em>gitignore/excludesfile</em>. And through <em>vcsh write-gitignore</em>, vcsh provides us the means to do so. The generated excludesfile is a white-list, for the ack example above, the final generated .gitignore.d/ack file is as follows</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">*
!.ackrc
!.gitignore.d/
!.gitignore.d/ack</code></pre></div>

<p>The first line ignores all files in $HOME and then starts including the files we’re tracking one by one. While this is well and good for normal use-cases, it does cause you to forget adding new files. For example, the generated excludesfile for mr is</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">*
!.config
!.config/mr
!.config/mr/available.d
!.config/mr/available.d/mr.vcsh
!.config/mr/available.d/git.vcsh
!.config/mr/config.d
!.config/mr/config.d/mr.vcsh
!.config/mr/config.d/git.vcsh
!.gitignore.d/
!.gitignore.d/mr
!.mrconfig</code></pre></div>

<p>Do you see the problem? Okay let me tell you, any new file in <em>available.d/ or config.d/</em> is ignored by default. So, I’d advise using the following <em>.gitignore.d/mr</em> file which tracks files by default.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">*
!.config
!.config/mr
!.config/mr/available.d
!.config/mr/available.d/*
!.config/mr/config.d
!.config/mr/config.d/*
!.gitignore.d
!.gitignore.d/mr
!.mrconfig</code></pre></div>

<p>A final note on the four sub steps required in Step 9 of [Adding a new repository].
1. Generate a gitignore file.
2. Force add the gitignore file to index, which is ignored up till now.
3. Regenerate the gitignore file (this time it will include the gitignore file itself).
4. Add the now modified gitignore file.</p>

<h2 id="caveats">Caveats</h2>

<ol>
  <li>
    <strike>The lack a git prompt in my terminal for vcsh enabled repos is unnerving. I still need to soak it all in and find a system to track pending changes. </strike>
  </li>
  <li>All repositories need to share a common README file. Again, I need to find a way around this.</li>
  <li>
    <strike>I don't like the manual symlinking required in .config.d/. It would be much easier to have helper functions like Apache provides for it's web server.</strike>
  </li>
</ol>

<p><strong>Update</strong>:</p>

<ol>
  <li>vcsh version 1.2 onwards solves 1 using a <strong>vcsh status</strong> command.</li>
  <li><a href="https://github.com/srijanshetty/custom/blob/master/functions/myrepos.zsh">This</a> script creates wrappers for automating most of this.</li>
</ol>
